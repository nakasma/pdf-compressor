<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>セキュアPDF/画像圧縮ツール (白基調)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts (Roboto) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- Tailwind Config -->
    <script>
        tailwind.config = {
            // Dark mode config removed to enforce light mode
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Roboto', 'sans-serif'],
                    },
                    colors: {
                        primary: {
                            50: '#f0f4ff',
                            100: '#dbeafe',
                            200: '#bfdbfe',
                            300: '#93c5fd',
                            400: '#60a5fa',
                            500: '#3b82f6',
                            600: '#2563eb',
                            700: '#1d4ed8',
                            800: '#1e40af',
                            900: '#1e3a8a',
                        },
                    },
                    boxShadow: {
                        'elevation-1': '0 1px 2px rgba(0,0,0,0.3), 0 1px 3px 1px rgba(0,0,0,0.15)',
                        'elevation-2': '0 1px 2px rgba(0,0,0,0.3), 0 2px 6px 2px rgba(0,0,0,0.15)',
                        'elevation-3': '0 4px 8px 3px rgba(0,0,0,0.15), 0 1px 3px rgba(0,0,0,0.3)',
                    }
                }
            }
        }
    </script>

    <!-- pdf-lib & pako -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    
    <!-- heic2any (HEIC変換用) -->
    <script src="https://unpkg.com/heic2any@0.0.4/dist/heic2any.min.js"></script>
    
    <style>
        .fade-in { animation: fadeIn 0.4s cubic-bezier(0.2, 0, 0, 1) forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
            70% { box-shadow: 0 0 0 12px rgba(59, 130, 246, 0); }
            100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
        }
        .drag-active {
            animation: pulse-ring 2s infinite;
            border-color: #3b82f6 !important;
            background-color: #eff6ff !important;
        }

        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 99px; }
        
        .ripple { position: relative; overflow: hidden; }
        .ripple::after {
            content: ""; display: block; position: absolute; width: 100%; height: 100%; top: 0; left: 0;
            pointer-events: none; background-image: radial-gradient(circle, #fff 10%, transparent 10.01%);
            background-repeat: no-repeat; background-position: 50%; transform: scale(10, 10); opacity: 0; transition: transform .5s, opacity 1s;
        }
        .ripple:active::after { transform: scale(0, 0); opacity: .3; transition: 0s; }
    </style>
</head>
<body class="bg-[#f0f2f5] text-gray-900 font-sans min-h-screen flex flex-col items-center py-12 px-4">

    <!-- Header -->
    <header class="mb-8 text-center max-w-2xl fade-in" style="animation-delay: 0.1s;">
        <h1 class="text-3xl md:text-4xl font-bold mb-3 tracking-tight text-gray-800">PDF/画像 圧縮ツール</h1>
        <p class="text-gray-600 text-base md:text-lg leading-relaxed">
            PDFは、テキストやリンクを保持したまま、画像だけを圧縮します。<br class="hidden md:inline">
            サーバー通信なしで安全に軽量化します。
        </p>
    </header>

    <!-- Main Card -->
    <main class="w-full max-w-[600px] bg-white rounded-[28px] shadow-elevation-1 p-6 md:p-8 fade-in" style="animation-delay: 0.2s;">
        
        <!-- Quality Settings -->
        <div class="mb-8">
            <div class="flex items-center justify-between mb-4">
                <label class="text-sm font-medium text-gray-700 px-1">圧縮クオリティ</label>
            </div>
            
            <div class="grid grid-cols-3 gap-3">
                <label class="cursor-pointer group relative">
                    <input type="radio" name="quality" value="high" class="peer sr-only">
                    <div class="h-full rounded-2xl border border-gray-200 p-3 text-center transition-all duration-200 hover:bg-gray-50 peer-checked:border-primary-500 peer-checked:bg-primary-50 peer-checked:text-primary-700">
                        <div class="font-medium text-sm">高画質</div>
                        <div class="text-[10px] opacity-70 mt-0.5">圧縮率: 低</div>
                    </div>
                </label>
                <label class="cursor-pointer group relative">
                    <input type="radio" name="quality" value="medium" class="peer sr-only" checked>
                    <div class="h-full rounded-2xl border border-gray-200 p-3 text-center transition-all duration-200 hover:bg-gray-50 peer-checked:border-primary-500 peer-checked:bg-primary-50 peer-checked:text-primary-700">
                        <div class="font-medium text-sm">標準</div>
                        <div class="text-[10px] opacity-70 mt-0.5">バランス</div>
                    </div>
                </label>
                <label class="cursor-pointer group relative">
                    <input type="radio" name="quality" value="low" class="peer sr-only">
                    <div class="h-full rounded-2xl border border-gray-200 p-3 text-center transition-all duration-200 hover:bg-gray-50 peer-checked:border-primary-500 peer-checked:bg-primary-50 peer-checked:text-primary-700">
                        <div class="font-medium text-sm">低画質</div>
                        <div class="text-[10px] opacity-70 mt-0.5">圧縮率: 高</div>
                    </div>
                </label>
            </div>
        </div>

        <!-- Upload Zone -->
        <div id="drop-zone" class="relative group cursor-pointer">
            <input type="file" id="file-input" accept="application/pdf, image/jpeg, image/png, image/heic, image/heif, .heic" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10">
            
            <div class="border-2 border-dashed border-gray-300 rounded-[24px] p-10 text-center transition-all duration-300 group-hover:border-primary-400 group-hover:bg-primary-50/50">
                <div class="mx-auto h-14 w-14 bg-gray-100 text-gray-500 rounded-full flex items-center justify-center mb-4 transition-transform duration-300 group-hover:scale-110 group-hover:bg-primary-100 group-hover:text-primary-600">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                </div>
                <p class="text-base font-medium text-gray-800">ファイルをドロップして開始</p>
                <p class="text-sm text-gray-500 mt-2">対応: PDF, JPEG, PNG, HEIC</p>
            </div>
        </div>

        <!-- Progress Section -->
        <div id="progress-container" class="hidden mt-8 fade-in">
            <div class="flex justify-between items-center text-sm font-medium text-gray-700 mb-3 px-1">
                <span id="progress-status" class="flex items-center gap-2">
                    <svg class="animate-spin h-4 w-4 text-primary-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    処理中...
                </span>
                <span id="progress-percent" class="font-bold text-primary-600">0%</span>
            </div>
            
            <div class="w-full bg-gray-100 rounded-full h-2 overflow-hidden mb-4">
                <div id="progress-bar" class="bg-primary-500 h-2 rounded-full transition-all duration-300 ease-out" style="width: 0%"></div>
            </div>
            
            <div id="log-area" class="text-xs font-mono text-gray-500 h-24 overflow-y-auto border border-gray-100 rounded-xl p-3 bg-gray-50 custom-scrollbar whitespace-pre-wrap leading-relaxed"></div>
        </div>

        <!-- Result Section -->
        <div id="result-container" class="hidden mt-8 fade-in">
            <div class="bg-green-50 border border-green-100 rounded-[20px] p-6 mb-6 text-center">
                <div class="mx-auto h-12 w-12 bg-green-100 text-green-600 rounded-full flex items-center justify-center mb-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                    </svg>
                </div>
                
                <h3 class="text-lg font-bold text-green-800 mb-1">完了しました</h3>
                
                <div class="flex items-center justify-center gap-4 my-5">
                    <div class="text-right">
                        <div class="text-[10px] text-gray-500 uppercase tracking-wider mb-0.5">Before</div>
                        <div class="font-medium text-gray-500 line-through text-sm" id="original-size">-</div>
                    </div>
                    <div class="text-gray-300">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <div class="text-left">
                        <div class="text-[10px] text-green-700 uppercase tracking-wider mb-0.5">After</div>
                        <div class="font-bold text-xl text-green-700" id="compressed-size">-</div>
                    </div>
                </div>
                
                <div class="inline-flex items-center bg-white border border-green-200 px-3 py-1 rounded-full">
                    <span class="text-xs font-bold text-green-700"><span id="reduction-rate">0</span>% 削減</span>
                </div>
            </div>

            <button id="download-btn" class="ripple w-full bg-primary-600 hover:bg-primary-700 text-white font-medium py-4 px-6 rounded-[20px] shadow-elevation-2 hover:shadow-elevation-3 transition-all duration-200 flex justify-center items-center gap-2 active:scale-[0.99]">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                </svg>
                ダウンロード
            </button>
            
            <button id="reset-btn" class="w-full mt-4 text-primary-600 text-sm font-medium hover:bg-primary-50 py-3 rounded-[20px] transition-colors">
                別のファイルを処理
            </button>
        </div>

        <!-- Note -->
        <div class="mt-8 pt-6 border-t border-gray-100 flex items-start gap-3">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400 mt-0.5 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <p class="text-xs text-gray-500 leading-relaxed">
                <strong class="font-medium text-gray-700">ご注意:</strong> 
                50MBを超えるファイルや、高解像度のHEIC画像の変換には時間がかかる場合があります。安全のため、処理が3分を超過すると自動的に停止します。
            </p>
        </div>

    </main>
    
    <footer class="mt-8 text-gray-400 text-[10px] uppercase tracking-widest font-medium">
        Secure Client-side Processing
    </footer>

    <script type="module">
        const { PDFDocument, PDFName, PDFRawStream } = PDFLib;

        // --- タイムアウト設定 (ミリ秒) ---
        const TIMEOUT_LIMIT_MS = 180000; // 3分

        // --- UI Elements ---
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const progressBar = document.getElementById('progress-bar');
        const progressStatus = document.getElementById('progress-status');
        const progressPercent = document.getElementById('progress-percent');
        const logArea = document.getElementById('log-area');
        const resultContainer = document.getElementById('result-container');
        const progressContainer = document.getElementById('progress-container');

        let currentDownloadUrl = null;

        // --- Event Listeners ---
        dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('drag-active'); });
        dropZone.addEventListener('dragleave', e => { e.preventDefault(); dropZone.classList.remove('drag-active'); });
        dropZone.addEventListener('drop', e => {
            e.preventDefault();
            dropZone.classList.remove('drag-active');
            if (e.dataTransfer.files.length > 0) handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', e => { if (e.target.files.length > 0) handleFiles(e.target.files); });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            location.reload(); // Simple reset
        });

        // --- Helper Functions ---
        function log(msg) {
            logArea.textContent += `> ${msg}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // --- Main Handler ---
        function handleFiles(files) {
            const file = files[0];
            const type = file.type;
            const name = file.name.toLowerCase();

            // HEIC check
            const isHeic = type === 'image/heic' || type === 'image/heif' || name.endsWith('.heic');

            if (type === 'application/pdf') {
                processPdf(file);
            } else if (type === 'image/jpeg' || type === 'image/png' || isHeic) {
                processImage(file);
            } else {
                alert('対応していないファイル形式です。\nPDF, JPEG, PNG, HEIC形式を選択してください。');
            }
        }

        function getCompressionSettings() {
            const qualitySetting = document.querySelector('input[name="quality"]:checked').value;
            // High: 0.8/0.9, Medium: 0.5/0.7, Low: 0.3/0.5
            return {
                high:   { q: 0.8, s: 0.9 },
                medium: { q: 0.5, s: 0.7 },
                low:    { q: 0.3, s: 0.5 }
            }[qualitySetting];
        }

        // --- Image Processing Logic (New) ---
        async function processImage(file) {
            // UI Init
            dropZone.classList.add('hidden');
            progressContainer.classList.remove('hidden');
            
            log('画像を読み込んでいます...');
            const settings = getCompressionSettings();

            try {
                let imageSource = file;
                const name = file.name.toLowerCase();
                const isHeic = file.type === 'image/heic' || file.type === 'image/heif' || name.endsWith('.heic');

                // HEIC Conversion Logic
                if (isHeic) {
                    log('HEIC形式を検出しました。変換中...');
                    progressBar.style.width = '10%';
                    progressPercent.innerText = '10%';
                    
                    try {
                        // heic2anyでBlob(JPEG)に変換
                        const convertedBlob = await heic2any({
                            blob: file,
                            toType: 'image/jpeg',
                            quality: 0.9 // 変換時は高画質で維持し、後でCanvas圧縮する
                        });
                        // 配列で返る場合もあるので正規化
                        imageSource = Array.isArray(convertedBlob) ? convertedBlob[0] : convertedBlob;
                        log('HEIC変換完了');
                    } catch (e) {
                        throw new Error('HEIC画像の変換に失敗しました: ' + e.message);
                    }
                }

                // 1. Load Image (Universal)
                const imgBitmap = await createImageBitmap(imageSource);
                
                progressBar.style.width = '30%';
                progressPercent.innerText = '30%';
                log(`画像サイズ: ${imgBitmap.width}x${imgBitmap.height}`);

                // 2. Compress via Canvas
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                const targetW = Math.floor(imgBitmap.width * settings.s);
                const targetH = Math.floor(imgBitmap.height * settings.s);

                canvas.width = targetW;
                canvas.height = targetH;

                // 背景を白にする（透過PNG対策）
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, targetW, targetH);
                ctx.drawImage(imgBitmap, 0, 0, targetW, targetH);

                progressBar.style.width = '60%';
                progressPercent.innerText = '60%';
                log('PDFを作成中...');

                // 3. Convert to JPEG Blob
                const newBlob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', settings.q));
                const newBytes = await newBlob.arrayBuffer();

                // 4. Create PDF
                const pdfDoc = await PDFDocument.create();
                const jpgImage = await pdfDoc.embedJpg(newBytes);
                
                // ページ追加
                const page = pdfDoc.addPage([targetW, targetH]);
                page.drawImage(jpgImage, {
                    x: 0,
                    y: 0,
                    width: targetW,
                    height: targetH,
                });

                progressBar.style.width = '90%';
                progressPercent.innerText = '90%';
                log('ファイルを保存中...');

                const pdfBytes = await pdfDoc.save();
                const compressedBlob = new Blob([pdfBytes], { type: 'application/pdf' });

                // Finish
                showResult(file, compressedBlob, '_converted.pdf');

            } catch (err) {
                console.error(err);
                alert('エラーが発生しました: ' + err.message);
                
                const statusElem = document.getElementById('progress-status');
                statusElem.innerText = 'エラー';
                statusElem.classList.add('text-red-500');
                progressBar.classList.add('bg-red-500');
                log('エラー: ' + err.message);
            }
        }

        // --- PDF Processing Logic (Existing) ---
        async function processPdf(file) {
            // UI Init
            dropZone.classList.add('hidden');
            progressContainer.classList.remove('hidden');
            
            const settings = getCompressionSettings();
            const startTime = Date.now();

            try {
                log('PDFを読み込み中...');
                const arrayBuffer = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(arrayBuffer);
                const context = pdfDoc.context;

                log('画像オブジェクトを検索中...');
                const objects = context.enumerateIndirectObjects();
                const imageObjects = [];

                for (const [ref, obj] of objects) {
                    if (obj instanceof PDFRawStream) {
                        const dict = obj.dict;
                        if (dict.get(PDFName.of('Subtype')) === PDFName.of('Image')) {
                            const filter = dict.get(PDFName.of('Filter'));
                            let primaryFilter = filter;
                            if (filter instanceof Array) {
                                primaryFilter = filter[filter.length - 1];
                            }
                            if (primaryFilter === PDFName.of('DCTDecode') || primaryFilter === PDFName.of('FlateDecode')) {
                                imageObjects.push({ ref, obj, filter: primaryFilter });
                            }
                        }
                    }
                }

                log(`圧縮対象の画像: ${imageObjects.length}枚`);
                
                if (imageObjects.length === 0) {
                    alert('圧縮可能な画像が見つかりませんでした。');
                    location.reload();
                    return;
                }

                let processed = 0;
                let skipped = 0;
                let totalSaved = 0;

                for (let i = 0; i < imageObjects.length; i++) {
                    if (Date.now() - startTime > TIMEOUT_LIMIT_MS) throw new Error('TIMEOUT_EXCEEDED');

                    const { ref, obj, filter } = imageObjects[i];
                    const pct = Math.round((i / imageObjects.length) * 100);
                    progressBar.style.width = `${pct}%`;
                    progressPercent.innerText = `${pct}%`;
                    
                    await new Promise(r => setTimeout(r, 0)); 

                    try {
                        let width = obj.dict.get(PDFName.of('Width'))?.value;
                        let height = obj.dict.get(PDFName.of('Height'))?.value;
                        let colorSpace = obj.dict.get(PDFName.of('ColorSpace'));
                        let bits = obj.dict.get(PDFName.of('BitsPerComponent'))?.value || 8;
                        const rawContent = obj.getContents();

                        let imgData = null; 

                        if (filter === PDFName.of('DCTDecode')) {
                            const blob = new Blob([rawContent], { type: 'image/jpeg' });
                            imgData = await blobToImageData(blob);
                        } else if (filter === PDFName.of('FlateDecode')) {
                            let components = 3; 
                            if (colorSpace === PDFName.of('DeviceGray')) components = 1;
                            else if (colorSpace === PDFName.of('DeviceCMYK')) components = 4;
                            else if (colorSpace instanceof Array) { skipped++; continue; }

                            if (bits !== 8) { skipped++; continue; }

                            let decoded;
                            try { decoded = pako.inflate(rawContent); } catch (e) { skipped++; continue; }

                            const predictor = obj.dict.get(PDFName.of('DecodeParms'))?.get(PDFName.of('Predictor'))?.value || 1;
                            if (predictor >= 10) decoded = applyPngPredictor(decoded, width, height, components, predictor);

                            imgData = rawToImageData(decoded, width, height, components);
                        }

                        if (!imgData) { skipped++; continue; }

                        // Resize & Compress Logic (Canvas)
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const targetW = Math.floor(imgData.width * settings.s);
                        const targetH = Math.floor(imgData.height * settings.s);
                        
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = imgData.width;
                        tempCanvas.height = imgData.height;
                        tempCanvas.getContext('2d').putImageData(imgData, 0, 0);

                        canvas.width = targetW;
                        canvas.height = targetH;
                        
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, targetW, targetH);
                        ctx.drawImage(tempCanvas, 0, 0, targetW, targetH);

                        const newBlob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', settings.q));
                        const newBytes = new Uint8Array(await newBlob.arrayBuffer());

                        if (newBytes.length < rawContent.length) {
                            obj.contents = newBytes;
                            obj.dict.set(PDFName.of('Filter'), PDFName.of('DCTDecode'));
                            obj.dict.set(PDFName.of('ColorSpace'), PDFName.of('DeviceRGB'));
                            obj.dict.set(PDFName.of('BitsPerComponent'), 8);
                            obj.dict.set(PDFName.of('Width'), targetW);
                            obj.dict.set(PDFName.of('Height'), targetH);
                            obj.dict.delete(PDFName.of('DecodeParms')); 

                            processed++;
                            totalSaved += (rawContent.length - newBytes.length);
                            log(`Img#${i+1}: 圧縮成功 (${formatBytes(rawContent.length)} -> ${formatBytes(newBytes.length)})`);
                        } else {
                            skipped++;
                        }

                    } catch (e) {
                        console.error(e);
                        skipped++;
                    }
                }

                progressBar.style.width = '100%';
                
                log(`完了: 変換${processed}件, スキップ${skipped}件`);
                
                const pdfBytes = await pdfDoc.save();
                const compressedBlob = new Blob([pdfBytes], { type: 'application/pdf' });

                showResult(file, compressedBlob, '_compressed.pdf');

            } catch (err) {
                if (err.message === 'TIMEOUT_EXCEEDED') {
                    alert('処理時間が制限（3分）を超えたため中断しました。');
                    log('エラー: タイムアウト中断');
                } else {
                    alert('エラーが発生しました: ' + err.message);
                    console.error(err);
                }
                const statusElem = document.getElementById('progress-status');
                statusElem.innerText = '処理中断';
                statusElem.classList.add('text-red-500');
                progressBar.classList.remove('bg-primary-500');
                progressBar.classList.add('bg-red-500');
            }
        }

        // --- Result Display Helper ---
        function showResult(originalFile, resultBlob, suffix) {
            progressContainer.classList.add('hidden');
            resultContainer.classList.remove('hidden');
            
            document.getElementById('original-size').innerText = formatBytes(originalFile.size);
            document.getElementById('compressed-size').innerText = formatBytes(resultBlob.size);
            
            const reduction = originalFile.size > 0 ? ((originalFile.size - resultBlob.size) / originalFile.size * 100).toFixed(1) : 0;
            document.getElementById('reduction-rate').innerText = reduction;

            if (currentDownloadUrl) URL.revokeObjectURL(currentDownloadUrl);
            currentDownloadUrl = URL.createObjectURL(resultBlob);
            
            const dlBtn = document.getElementById('download-btn');
            dlBtn.onclick = () => {
                const a = document.createElement('a');
                a.href = currentDownloadUrl;
                const baseName = originalFile.name.substring(0, originalFile.name.lastIndexOf('.')) || originalFile.name;
                a.download = `${baseName}${suffix}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            };
        }

        // --- Utilities for Image Decoding (Existing) ---
        function blobToImageData(blob) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const url = URL.createObjectURL(blob);
                img.onload = () => {
                    const c = document.createElement('canvas');
                    c.width = img.width;
                    c.height = img.height;
                    const ctx = c.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    URL.revokeObjectURL(url);
                    resolve(ctx.getImageData(0, 0, img.width, img.height));
                };
                img.onerror = reject;
                img.src = url;
            });
        }

        function rawToImageData(raw, w, h, components) {
            const data = new Uint8ClampedArray(w * h * 4);
            let rawIdx = 0;
            let dataIdx = 0;
            const size = w * h;

            if (raw.length < size * components) return null; 

            for (let i = 0; i < size; i++) {
                if (components === 1) { // Gray
                    const g = raw[rawIdx++];
                    data[dataIdx++] = g; data[dataIdx++] = g; data[dataIdx++] = g; data[dataIdx++] = 255;
                } else if (components === 3) { // RGB
                    data[dataIdx++] = raw[rawIdx++]; data[dataIdx++] = raw[rawIdx++]; data[dataIdx++] = raw[rawIdx++]; data[dataIdx++] = 255;
                } else if (components === 4) { // CMYK
                    const c = raw[rawIdx++] / 255; const m = raw[rawIdx++] / 255; const y = raw[rawIdx++] / 255; const k = raw[rawIdx++] / 255;
                    const r = 1 - Math.min(1, c * (1 - k) + k);
                    const g = 1 - Math.min(1, m * (1 - k) + k);
                    const b = 1 - Math.min(1, y * (1 - k) + k);
                    data[dataIdx++] = r * 255; data[dataIdx++] = g * 255; data[dataIdx++] = b * 255; data[dataIdx++] = 255;
                }
            }
            return new ImageData(data, w, h);
        }

        function applyPngPredictor(data, w, h, bpp, predictor) {
            if (predictor < 10) return data;
            const rowSize = w * bpp + 1;
            const rawSize = w * bpp;
            const output = new Uint8Array(w * h * bpp);
            let prevRow = new Uint8Array(rawSize);
            
            for (let y = 0; y < h; y++) {
                const rowOffset = y * rowSize;
                const filterType = data[rowOffset];
                const rowData = data.subarray(rowOffset + 1, rowOffset + rowSize);
                const outRowOffset = y * rawSize;
                const currRow = new Uint8Array(rawSize);

                for (let x = 0; x < rawSize; x++) {
                    const rawByte = rowData[x];
                    const left = x >= bpp ? currRow[x - bpp] : 0;
                    const up = prevRow[x];
                    const upLeft = x >= bpp ? prevRow[x - bpp] : 0;
                    
                    let val = 0;
                    switch (filterType) {
                        case 0: val = rawByte; break;
                        case 1: val = rawByte + left; break;
                        case 2: val = rawByte + up; break;
                        case 3: val = rawByte + Math.floor((left + up) / 2); break;
                        case 4: 
                            const p = left + up - upLeft;
                            const pa = Math.abs(p - left);
                            const pb = Math.abs(p - up);
                            const pc = Math.abs(p - upLeft);
                            if (pa <= pb && pa <= pc) val = rawByte + left;
                            else if (pb <= pc) val = rawByte + up;
                            else val = rawByte + upLeft;
                            break;
                        default: val = rawByte;
                    }
                    currRow[x] = val & 0xFF;
                    output[outRowOffset + x] = val & 0xFF;
                }
                prevRow = currRow;
            }
            return output;
        }

    </script>
</body>
</html>